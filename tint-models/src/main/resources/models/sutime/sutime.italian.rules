### Definitions

IsoDateTime = { type: "CLASS", value: "edu.stanford.nlp.time.SUTime$IsoDateTime" }



### Patterns

$REL_MOD_FOLL = ( /prossim[ao]|seguente|quest[ao]|scors[ao]/ );
$REL_MOD_PREC = ( /il|lo|la|l'/? ( $REL_MOD_FOLL ) );
$EARLY_LATE_MOD_PREC = ( /tard[ao]|presto|primo|metà/ );
$EARLY_LATE_MOD_FOLL = ( /tardi|presto/ );

$hasTemporal = "( { temporal::EXISTS } & {{ temporal.value != NON_TEMPORAL }} & !{{ tags[\"TIMEZONE\"] }} )"



### Appenders

ENV.defaults["stage"] = 0
ENV.defaults["ruleType"] = "tokens"

{ pattern: ( /prossim[oa]/ ), action: Tag($0, "TemporalOp", NEXT_IMMEDIATE) }
{ pattern: ( /scors[oa]/ ), action: Tag($0, "TemporalOp", PREV_IMMEDIATE) }
{ pattern: ( /quest[oa]/ ), action: Tag($0, "TemporalOp", THIS) }

{ pattern: ( /tard[aio]/ ), action: Tag($0, "Modifier", "LATE") }
{ pattern: ( /presto|primo/ ), action: Tag($0, "Modifier", "EARLY") }
{ pattern: ( /metà/ ), action: Tag($0, "Modifier", "MID") }



### Forms

ENV.defaults["stage"] = 1

$Decades = CreateRegex(Keys(DECADES_MAP));
$DAY_NAME = CreateRegex(Keys(DAY_MAP));
$MONTH_NAME = CreateRegex(Keys(MONTH_MAP));

{ (/ieri/) => YESTERDAY }
{ (/oggi/) => TODAY }
{ (/domani/) => TOMORROW }
{ (/stanotte|stasera/) => TONIGHT }

{ (/ann[oi]/) => YEAR }
{ (/mes[ei]/) => MONTH }
{ (/giorn[oi]/) => DAY }
{ (/or[ae]/) => HOUR }
{ (/minut[oi]/) => MINUTE }
{ (/second[oi]/) => SECOND }
{ (/millisecond[oi]/) => MILLIS }
{ (/settiman[ae]/) => WEEK }
{ (/trimestr[ei]/) => QUARTER }
{ (/decad[ei]/) => DECADE }
{ (/secol[oi]/) => CENTURY }
{ (/millennio?/) => MILLENNIUM }

{ ( /il/? (/primo/)? /(po)?meriggio/ ) => AFTERNOON }
{ ( /in/? /ser(a|ata)/ ) => EVENING }
{ ( /a/ /il/ /tramonto/ ) => SUNSET }
{ ( /a/ /il/ /crepuscolo/ ) => TWILIGHT }
{ ( /a/ /l'/ /alba/ ) => SUNRISE }
{ ( /a/ /l'/ /aurora/ ) => DAWN }
{ ( (/a|la|per/ | /a/ /la/)? /mezzanotte/ ) => MIDNIGHT }
{ ( (/a|per/)? /mezzogiorno/ ) => NOON }
{ ( /a/ /la/ /mezza/ ) => NOON }
{ ( (/a|per/ | /a/ /l'/)? (/ora/ /di/) /pranzo/ ) => LUNCHTIME }
{ ( (/a|per/ | /a/ /l'/)? (/ora/ /di/) /cena/ ) => DINNERTIME }
{ ( /in/ /giornata/ ) => DAYTIME }
{ ( /di/ /giorno/ ) => DAYTIME }
{ ( /in/ /nottata/ ) => NIGHT }
{ ( /di/ /notte/ ) => NIGHT }

# time
# EX: Vado a fare la spesa alle 14. -> YES
# EX: Vado a fare la spesa alle 14 -> YES
# EX: Vado a fare la spesa dalle 2 alle 14 volte. -> NO
#{ ( /le/ (/[0-9]{1,2}/) [!{ tag:S }] ) => IsoTime($1[0].numcompvalue, 0, 0) }
{
  pattern: ( (/le/ (/[0-9]{1,2}/)) [ !{ tag:S } ] ),
  result: IsoTime($2[0].numcompvalue, 0, 0),
  matchedExpressionGroup: 1
}
{
  pattern: ( /le/ (/[0-9]{1,2}/) $ ),
  result: IsoTime($1[0].numcompvalue, 0, 0)
}

# full date
{ (/il|l'|l'/? (/[0-9]{1,2}/) /di/? (/$MONTH_NAME/) (/di/ /il/)? (/[0-9]{4}/)) => IsoDate($4[0].numcompvalue, MONTH_MAP[$2[0].word], $1[0].numcompvalue) }
{ ( /([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{4})/ ) => IsoDate($3[0].numcompvalue, $2[0].numcompvalue, $1[0].numcompvalue) }
{ ( ( /[0-9]{1,2}/ ) /\// ( /[0-9]{1,2}/ ) /\// ( /[0-9]{4}/ ) ) => IsoDate($3[0].numcompvalue, $2[0].numcompvalue, $1[0].numcompvalue) }

#{ ( (/[0-9]{4}-[0-9]{2}-[0-9]{2}/) ) => IsoDate($1[0].word.substring(0, 4), $1[0].word.substring(5, 7), $1[0].word.substring(8, 10)) }
{ ruleType: "time", pattern: /yyyy-?MM-?dd-?'T'HH(:?mm(:?ss([.,]S{1,3})?)?)?(Z)?/ }
{ ruleType: "time", pattern: /yyyy-MM-dd/ }
{ ruleType: "time", pattern: /HH:mm/ }

# day and month
{ (/il|l'|l'/? (/[0-9]{1,2}/) /di/? (/$MONTH_NAME/)) => IsoDate(NIL, MONTH_MAP[$2[0].word], $1[0].numcompvalue) }

# month and year
{ ((/$MONTH_NAME/) (/di/ /il/)? (/[0-9]{4}/)) => IsoDate($3[0].numcompvalue, MONTH_MAP[$1[0].word], NIL) }

#month
{ ((/$MONTH_NAME/)) => MonthOfYear(MONTH_MAP[$1[0].word]) }

# decade
{ (/gli/? /anni/ /'|’/? (/$Decades/) ) => IsoDate( Concat("19", DECADES_MAP[Lowercase($1[0].word)]), NIL, NIL) }

# days of the week
{ (/$DAY_NAME/) => DayOfWeek(DAY_MAP[$0[0].word]) }



### Compositional rules

ENV.defaults["stage"] = 3
ENV.defaults["ruleType"] = "tokens"

ENV.defaults["ruleType"] = "composite"

# In getting the $x for inclusions, the external brackets does not count
{
  priority: 5,
  pattern: ( ( [ $hasTemporal & !{ temporal::IS_TIMEX_SET } ] ) ( $REL_MOD_FOLL ) ),
  result: RelativeTime( GetTag($2[0], "TemporalOp"), $1[0].temporal.value )
}
{
  priority: 4,
  pattern: ( ( $REL_MOD_PREC ) ( [ $hasTemporal & !{ temporal::IS_TIMEX_SET } ] ) ),
  result: RelativeTime( GetTag($2[0], "TemporalOp"), $3[0].temporal.value )
}
{
  pattern: ( /il|la/? ( $EARLY_LATE_MOD_PREC ) ( [ $hasTemporal & !{ temporal::IS_TIMEX_SET } ] ) ),
  result: TemporalCompose( ADD_MODIFIER, $2[0].temporal.value, GetTag($1[0], "Modifier") )
}

{
  pattern: ( /da/? ( [ { temporal::IS_TIMEX_TIME } ] ) /a|-/ ( [ { temporal::IS_TIMEX_TIME } ] ) ),
  result: TimeRange( $1[0].temporal.value, $2[0].temporal.value )
}

{
  pattern: ( /da/? ( [ { temporal::IS_TIMEX_DATE } ] ) /a|-/ ( [ { temporal::IS_TIMEX_DATE } ] ) ),
  result: TimeRange( $1[0].temporal.value, $2[0].temporal.value )
}

ENV.defaults["stage"] = 4
ENV.defaults["ruleType"] = "composite"

{
  pattern: ((
    ( [ $hasTemporal ] ) /,|di/? ( [ { temporal::IS_TIMEX_DATE } | { temporal::IS_TIMEX_TIME } ] ) |
    ( [ { temporal::IS_TIMEX_DATE } ] ) /a/ /le/? ( [ { temporal::IS_TIMEX_TIME } ] )
  )),
  result: TemporalCompose(INTERSECT, $1[-1].temporal, $1[0].temporal)
}



### Final checks

ENV.defaults["stage"] = 5
ENV.defaults["ruleType"] = "tokens"

{
  pattern: ( /da/ /le/ /[0-9]{1,2}/ /a/ /le/ /[0-9]{1,2}/ [{ tag:S }] ),
  result: NON_TEMPORAL
}



### Final filtering rules

ENV.defaults["ruleType"] = "filter"
ENV.defaultTokensAnnotationKey = tokens

# {  pattern: ( $NUM /to/ $NUM) }
# {  pattern: ( /(quarter|sun)s?/ ) }
# {  pattern: ( [ { word:/(fall|spring|second|march|may|sat|sun|min)s?/ } & !{ tag:/NN.*/ } ] )  }
# {  pattern: ( /the/ [ { word:/second/ } & !{ tag:/NN.*/ } ] )  }
# {  pattern: ( [ { word:/((twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety)-)?second/ } ] )  }
# { pattern: ( [ {{ temporal.value == NON_TEMPORAL }} ] ), over: NIL }

# Reject anything that is just a timezone
# {  pattern: ( [ {{ tags["TIMEZONE"] }} ] ), over: NIL  }

